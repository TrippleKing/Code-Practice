# 动态规划

> 动态规划常常适用于**有重叠子问题**和**最优子结构**性质的问题，动态规划方法**所耗时间往往远少于朴素解法**.

## 主要思想

若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。

动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。

一旦某个给定子问题的解已经算出，则将其记忆存储，以便下次需要求解相同子问题时直接查询。

## 动态规划模板步骤

- 确定动态规划状态；
- 写出状态转移方程（画出状态转移表）
- 考虑初始化条件
- 考虑输出状态
- 考虑对时间、空间复杂度的优化

## 例题详解

### 300. 最长上升子序列

#### 题目描述

给定一个无序的整数数组，找到其中最长上升子序列的长度。

#### 示例

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

#### 说明

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为$O(n^2)$。

#### 进阶

你能将算法的时间复杂度降低到$O(n\log n)$吗？

#### 解题思路

- **确定动态规划状态**

  - 该题目可以直接用一个一维数组`dp`来存储转移状态，`dp[i]`可以定义为`nums[i]`这个数结尾的最长递增子序列的长度。例如：在`nums[10, 9, 2, 5, 3, 7, 101, 18]`中，`dp[0]`表示以数字`10`为结尾的最长递增子序列长度，那就是它本身，所以为`1`。对于`dp[5]`表示以数字`7`为结尾的最长递增子序列是`[2, 5, 7]`（或者`2, 3, 7`）所以`dp[5] = 3`。

- **写出一个好的状态转移方程**

  - 使用**数学归纳法**的思想，写出准确的状态方程。

  - 比如还是`nums[10, 9, 2, 5, 3, 7, 101, 18]`，我们思考**如何得到`dp[5] = 3`**：既然是递增的子序列，我们只要找到`nums[5]`（对应数字`7`）前面那些结尾比`7`小的子序列，然后把`7`接到最后，即可形成一个新的递增子序列，相当于长度`+1`。当然可能会找到很多不同的子序列，但是只需要确保长度最长作为`dp[5]`的值即可。总结来说就是比较当前`dp[i]`的长度和`dp[i]`对应产生新的子序列长度，我们用`j`来表示所有比`i`小的数组中的索引，可以用如下代码片段表示：

    ```python
    for i in range(len(nums)):
        for j in range(i):
        	if nums[i]>nums[j]:
        		dp[i]=max(dp[i],dp[j]+1)
    ```

  - **Tips：**在实际问题中，如果不能很快推出递推公式，可以先尝试一步一步把前面几步写出来，如果还是很难解决，很可能是`dp`数组的定义不够恰当，需要回到第一步重新定义`dp`数组的含义；或者可能是`dp`数组存储的信息还不够，不足以推出下一步的答案，需要把`dp`数组扩大到二维数组甚至三维数组。

- **考虑初始条件**

  - 这是决定整个程序是否能跑通的重要步骤，当我们确定好状态转移方程，就需要考虑边界值，主要从以下三个方面去考虑边界条件：
    - `dp`数组整体的初始值
    - `dp`数组（二维）`i = 0`和`j = 0`的地方
    - `dp`存放状态的长度，是整个数组的长度还是数组的长度加一，这一点需要考虑清楚
  - 对于本问题，子序列最少就是单个数字本身，所以长度为`1`，这样我们就可以方便地把`dp`数组整体的初始值都设为`1`，再考虑长度问题，由于`dp[i]`代表的是以`nums[i]`为结尾的最长子序列长度，所以并不需要加一。

- **考虑输出状态**

  - 主要有以下三种形式，对于具体问题，我们一定要想清楚`dp`数组里存储的是哪些值，最后我们需要的是数组中的那些值：
    - 返回`dp`数组中最后一个值作为输出，一般对应二维`dp`问题；
    - 返回`dp`数组中最大的那个数字，一般对应记录最大值问题；
    - 返回保存的最大值，一般是`maxval = max(maxval, dp[i])`这样的形式。
  - **Tips：**这个公式必须是在满足递增的条件下，即`nums[i] > nums[j]`的时候才能成立，并不是`nums[i]`前面所有数字都满足这个条件的，理解好这个条件就很同意懂接下来在输出的时候应该是`max(dp)`而不是`dp[-1]`。

- **完整代码**

  ```python
  def lengthOfLIS(self, nums: List[int]) -> int:
          if not nums:return 0  #判断边界条件
          dp=[1]*len(nums)      #初始化dp数组状态
          for i in range(len(nums)):
              for j in range(i):
                  if nums[i]>nums[j]:   #根据题目所求得到状态转移方程
                      dp[i]=max(dp[i],dp[j]+1)
          return max(dp)  #确定输出状态
  ```

- **考虑对时间、空间复杂度的优化**

  - **切入点**：上述方法，在遍历`dp`列表时需要$O(n)$，计算每个`dp[i]`又需要$O(n)$，所以总的复杂度是$O(n^2)$
  - 前面遍历`dp`列表的时间复杂度肯定是无法继续降低了，但是我们看到后面在每轮遍历`[0, i]`的`dp[i]`元素的时间复杂度可以考虑设计状态定义，使得整个`dp`为一个排序列表，这样就可以利用二分法来把时间复杂度降低到$O(n\log n)$。

- **改进方案**

  - 依然着眼于一个上升子序列的**结尾的元素**；

  - 如果已经得到的上升子序列的结尾的数越小，遍历的时候后面接上一个数，就会有更大的可能性构成一个更长的上升子序列；

  - 由此，我们改写状态定义，以数组`tail`加以区分：

    - `tail[i]`表示**长度为`i + 1`**的所有上升子序列的**结尾的最小值**。

    > `tail[0]`表示长度为`1`的所有上升子序列中，结尾最小的那个元素的数值，仍然以`nums[10, 9, 2, 5, 3, 7, 101, 18]`为例，容易发现长度为`2`的**所有**上升子序列中，结尾最小的子序列为`[2, 3]`，因此`tail[1] = 3`。

- **思考状态转移方程**

  - 从直觉上判断，数组`tail`是一个**严格上升**数组。（即有序）

  - 我们只需要维护状态数组`tail`的定义，它的长度就是最长上升子序列的长度。

  - **算法流程**：

    - 初始化数组`tail`，初始为空
    - 在遍历`nums`时，对每一个新数`num`，如果这个数**严格大于**`tail`数组的最后一个元素，就把`num`放到`tail`的后面。
    - 如果并非**严格大于**，则在`tail`中查找第一个大于等于`num`的那个数，试图让这个变小：
      - 如果`tail`中存在**等于**`num`的元素，什么都不做，因为以`num`结尾的上升子序列已经存在；
      - 如果`tail`中存在**大于**`num`的元素，找到第`1`个，让它变小，这样就找到了一个**结尾更小**的**相同长度**的上升子序列。

  - **代码**：

    ```python
    # 二分查找 + DP
    class Solution:
        def lengthOfLIS(self, nums: List[int]) -> int:
            if len(nums) < 2: return len(nums)
    
            tail = [nums[0]]
            for i in range(1, len(nums)):
                if nums[i] > tail[-1]:
                    tail.append(nums[i])
                    continue
                
                left = 0
                right = len(tail) - 1
                while left < right:
                    mid = (left + right) // 2
                    if tail[mid] < nums[i]:
                        left = mid + 1
                    else:
                        right = mid
                tail[left] = nums[i]
            return len(tail)
    ```

---

## 算法应用

### 674. 最长连续递增序列

#### 题目描述

给定一个未经排序的整数数组，找到最长且**连续**的递增序列，并返回该序列的长度。

#### 示例1

```
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 
```

#### 示例2

```
输入: [2,2,2,2,2]
输出: 1
解释: 最长连续递增序列是 [2], 长度为1。
```

#### 注意

数组长度不会超过10000

#### 解题思路

该问题咋一看和上面的例题非常像，这个题目最大的不同就是多了**连续**两个字，这样就让这个问题简单很多了。因为如果要求连续的话，就不需要和例题一样遍历两次数组，只需要比较前后的值是不是符合递增的关系即可。

- **确定动态规划**
  - 对于这个问题，我们的状态`dp[i]`也是以`nums[i]`为结尾的最长连续递增子序列的长度。
- **状态转移方程**
  - 若当前数字`nums[i]`比它前一个数字大，即`nums[i] > nums[i-1]`，那么以`nums[i]`结尾的最长连续递增子序列是以`nums[i-1]`结尾的子序列再加上`1`，即`dp[i] = dp[i-1] + 1`；
  - 若当前数字`nums[i]`不大于它的前一个数字`nums[i-1]`，那么以`nums[i]`结尾的子序列仅有它本身，长度为`1`，即`dp[i] = 1`。
- **考虑初始化条件**
  - 初始化为一个一维的全`1`数组。
- **考虑输出状态**
  - 输出`dp`数组的最大值即可。

#### 代码

```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        if len(nums) < 2: return len(nums)

        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                dp[i] = dp[i-1] + 1
        return max(dp)
```

---

### 5. 最长回文子串

#### 题目描述

给定一个字符串`s`，找到`s`中最长的回文子串。你可以假设`s`的最大长度为`1000`。

#### 示例1

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

#### 示例2

```
输入: "cbbd"
输出: "bb"
```

#### 解题思路

- **定义状态**

  - 这个题目需要用二维`dp`数组来记录状态，定义`d[i][j]`表示子串`s`从`i`到`j`是否为回文子串。

- **状态转移方程**

  - 字符串首尾两个字符必须相等，否则肯定不是回文；
  - 当字符串首尾两个字符相等时：如果子串是回文（即整体是回文），对于字符串`s`，如果`s[i] = s[j]`，则判断子串`s[i+1, j-1]`是否为回文，如果子串本身是空或者只有单元素那肯定是回文了，相应的`dp[i][j]`设置为`True`，否则为`False`。

- **考虑输出状态**

  - 在`dp`数组定义中，`dp[i][j]`代表字符串`s`从`i`到`j`是否构成回文子串，我们可以根据这一信息获取到回文子串的起始位置和结束位置，同时也知道该子串的长度


#### 代码

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) < 2: return s

        dp = [[False for _ in range(len(s))] for _ in range(len(s))]

        max_len = 1
        start = 0
        for i in range(len(s)):
            for j in range(i+1):
                if i == j:
                    dp[j][i] = True
                    continue
                if s[i] == s[j]:
                    dp[j][i] = ((i - j) == 1) or dp[j+1][i-1]

                if dp[j][i] == True:
                    if (i - j + 1) > max_len:
                        max_len = (i - j + 1)
                        start = j
        return s[start:start+max_len]
```

- **考虑对时间、空间复杂度的优化**
  - 对于这个问题，时间和空间都可以进一步优化：
    - **空间优化**：利用中心扩散法；
    - **时间优化**：Manacher's Algorithm。

#### 中心扩散法

通过**枚举**可能出现的回文子串的**中心位置**，从**中心位置**尝试尽可能向两侧**扩散**，得到尽可能长的回文串。所以，中心扩散的**核心思想**就是：遍历每一个索引，以这个索引为中心，利用**回文串中心对称**的特点，往两边扩散，得到最大扩散的情况。

该方法可以把空间复杂度降为$O(1)$，但时间复杂度依然是$O(n^2)$

还有一个需要**注意**的地方：

- 当回文串的长度为奇数或偶数的时候，**回文中心**的形式是不一样的：
  - 奇数回文串的中心是**一个字符**。（如：回文串`aba`的中心是`b`）
  - 偶数回文串的中心是**两个字符**。（如：回文串`abba`的中心是`bb`）

**代码**：

```python
# 中心扩散
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) < 2: return s
        max_len = 1
        res = s[0]

        for i in range(len(s)):
            sub_odd, len_odd = self.sub_string(s, len(s), i, i)
            sub_even, len_even = self.sub_string(s, len(s), i, i+1)

            cur_sub = sub_odd if len_odd >= len_even else sub_even
            if len(cur_sub) > max_len:
                max_len = len(cur_sub)
                res = cur_sub
        return res

    
    def sub_string(self, s, size, left, right):
        i = left
        j = right
        while i >= 0 and j < size and s[i] == s[j]:
            i -= 1
            j += 1
        
        return s[i+1:j], j-i-1
```

#### Manacher Algorithm（马拉车算法）

Manacher Algorithm直接看[链接](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)吧，这个算法就是专门设计用来解决最长回文子串这一问题的。限于篇幅，此处不再展开叙述。

---

### 516. 最长回文子序列

#### 题目描述

给定一个字符串`s`，找到其中最长的回文子序列，并返回该序列的长度。可以假设`s`的最大长度为`1000`。

#### 示例1

```
输入："bbbab"
输出：4
一个可能的最长回文子序列为 "bbbb"。
```

#### 示例2

```
输入："cbbd"
输出：2
一个可能的最长回文子序列为 "bb"。
```

#### 解题思路

- **确定动态规划状态**
  - 定义`dp[i][j]`表示字符串从第`i`个字符到第`j`个字符，可构成的最长回文子序列的长度。
- **状态转移方程**
  - 对于`dp[i][j]`，当`s[i] = s[j]`时，`dp[i][j] = dp[i+1][j-1] + 2`；当`s[i] != s[j]`时，表明`s[i]`和`s[j]`两个字符中**至多有一个**可以在字符串`s[i, j]`构成的最长回文子序列中出现，即`dp[i][j] = max(dp[i+1][j], dp[i][j-1])`。**注意**：这样设置的状态转移可以兼容地处理`s[i]`和`s[j]`两个字符都不出现在最长回文子序列的情况。

#### 代码

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        if len(s) < 2: return len(s)

        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]
        res = 1
        for i in range(len(s), -1, -1):
            for j in range(i, len(s)):
                if i == j:
                    dp[i][j] = 1
                    continue
                if s[i] == s[j]:
                    dp[i][j] = dp[i+1][j-1] + 2
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return dp[0][-1]
```

---

### 72. 编辑距离

#### 题目描述

给你两个单词`word1`和`word2`，请你计算出将`word1`转换成`word2`所使用的最少操作数。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

#### 示例1

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

#### 示例2

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

#### 解题思路

- **确定动态规划状态**
  - 定义`dp[i][j]`保存字符串`word1`长度为`i`和字符串`word2`长度为`j`时，`word1`转化为`word2`时的最少编辑距离。
- **状态转移方程**
  - 从**末尾**开始遍历`word1`和`word2`，当`word1[i] = word2[j]`时，`dp[i][j] = dp[i-1][j-1]`；
  - 当`word1[i] != word2[j]`时，需要分别对三种操作进行判断，取最少操作次数：
    - 对于**插入**操作：在`word1`中插入与`word2`一样的字符，即`dp[i][j] = dp[i-1][j] + 1`；
    - 对于**删除操作**：在`word2`中删除一个字符后，两者相等，即`dp[i][j] = dp[i][j-1] + 1`；
    - 对于**替换操作**：`dp[i][j] = dp[i-1][j-1] + 1`。
  - 所以，最终的状态转移方程可以写成`dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`。
- **考虑输出状态**
  - 输出`dp[-1][-1]`即可

#### 代码

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n = len(word1)
        m = len(word2)

        dp = [[0 for _ in range(m+1)] for _ in range(n+1)]

        for i in range(n+1):
            dp[i][0] = i
        for j in range(m+1):
            dp[0][j] = j
        
        for i in range(1, n+1):
            for j in range(1, m+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1
        return dp[-1][-1]
```

---

### 198. 打家劫舍

#### 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**不触动警报装置的情况下**，一夜之内能够偷窃到的最高金额。

#### 示例1

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

#### 示例2

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

#### 提示

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

#### 解题思路

- **确定动态规划状态**
  - 定义`dp[i]`表示偷窃第`i`号房子能够得到的最高金额。（索引从`0`开始）
- **状态转移方程**
  - 其实就是一个`0-1背包问题`，对于第`i`号房子，小偷有两种选择：
    - **偷**：偷第`i`号房子，那么意味着第`i-1`号房子一定不能偷，即`dp[i] = dp[i-2] + nums[i]`
    - **不偷**：不偷第`i`号房子，那么意味着第`i-1`号房子可以偷，即`dp[i] = dp[i-1]`
  - 所以`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`
- **考虑初始化条件**
  - 初始化条件需要考虑第一个房子和第二个房子，之后的房子都可以按照规律直接求解。当只有一个房子的时候，自然是要偷的；当只有两个房子时，选金额大的那一个偷，即`dp[0] = nums[0], dp[1] = max(nums[0], nums[1])`
- **考虑输出状态**
  - 输出`dp[-1]`即可

#### 代码

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums: return 0
        if len(nums) < 2: return nums[0]

        dp = [0 for _ in range(len(nums))]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-2] + nums[i], dp[i-1])
        return dp[-1]
```

---

### 213. 打家劫舍II

#### 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋，每间房屋内都藏有一定的现金。这个地方所有的房屋都**围成一圈**，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一个晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下**，能够偷窃到的最高金额。

#### 示例1

```
输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

#### 示例2

```
输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

#### 解题思路

这一题和上一题其实很相似，只不过把头尾房屋接起来了，即如果偷窃了第一个房子，那么不能偷窃最后一个；如果偷窃了最后一个，那么不能偷窃第一个。

由此，可以把原数组分为`nums[1:]`和`nums[:-1]`即可。

#### 代码

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums: return 0
        if len(nums) < 2: return nums[0]
        

        def recur(n):
            if not n: return 0
            if len(n) < 2: return n[0]
            dp = [0 for _ in range(len(n))]

            dp[0] = n[0]
            dp[1] = max(n[0], n[1])

            for i in range(2, len(n)):
                dp[i] = max(dp[i-2] + n[i], dp[i-1])
            
            return dp[-1]
        
        return max(recur(nums[1:]), recur(nums[:-1]))
```



